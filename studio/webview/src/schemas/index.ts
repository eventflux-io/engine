// Auto-generated EventFlux schema
// Generated by: cargo run --bin generate_schema

import schema from './eventflux-schema.json';

// Schema types
export interface ConnectorSchema {
  name: string;
  supportedFormats?: string[];
  requiredParameters?: string[];
  optionalParameters?: string[];
}

export interface MapperSchema {
  name: string;
  requiredParameters?: string[];
  optionalParameters?: string[];
}

export interface WindowSchema {
  name: string;
  description?: string;
}

export interface AggregatorSchema {
  name: string;
  arity: number;
  description?: string;
}

export interface FunctionSchema {
  name: string;
}

export interface CollectionAggregatorSchema {
  name: string;
  supportsCountOnly: boolean;
  description?: string;
}

export interface TableSchema {
  name: string;
}

export interface EventFluxSchema {
  version: string;
  generated: string;
  sources: Record<string, ConnectorSchema>;
  sinks: Record<string, ConnectorSchema>;
  mappers: Record<string, MapperSchema>;
  windows: Record<string, WindowSchema>;
  aggregators: Record<string, AggregatorSchema>;
  functions: Record<string, FunctionSchema>;
  collectionAggregators: Record<string, CollectionAggregatorSchema>;
  tables: Record<string, TableSchema>;
}

// Export the schema
export const eventFluxSchema = schema as EventFluxSchema;

// Helper functions
export function getSourceTypes(): string[] {
  return Object.keys(eventFluxSchema.sources).sort();
}

export function getSinkTypes(): string[] {
  return Object.keys(eventFluxSchema.sinks).sort();
}

export function getMapperTypes(): string[] {
  return Object.keys(eventFluxSchema.mappers).sort();
}

export function getWindowTypes(): string[] {
  return Object.keys(eventFluxSchema.windows).sort();
}

export function getAggregatorTypes(): string[] {
  return Object.keys(eventFluxSchema.aggregators).sort();
}

export function getFunctionNames(): string[] {
  return Object.keys(eventFluxSchema.functions).sort();
}

export function getTableExtensions(): string[] {
  return Object.keys(eventFluxSchema.tables).sort();
}

export function getSourceSchema(type: string): ConnectorSchema | undefined {
  return eventFluxSchema.sources[type];
}

export function getSinkSchema(type: string): ConnectorSchema | undefined {
  return eventFluxSchema.sinks[type];
}

export function getMapperSchema(type: string): MapperSchema | undefined {
  return eventFluxSchema.mappers[type];
}

// Get all parameters for a connector (required + optional)
export function getConnectorParameters(connector: ConnectorSchema): { key: string; required: boolean }[] {
  const params: { key: string; required: boolean }[] = [];

  for (const key of connector.requiredParameters || []) {
    params.push({ key, required: true });
  }

  for (const key of connector.optionalParameters || []) {
    params.push({ key, required: false });
  }

  return params;
}

// Format parameter name for display (e.g., "rabbitmq.host" -> "Host")
export function formatParameterName(param: string): string {
  // Remove connector prefix (e.g., "rabbitmq.host" -> "host")
  const parts = param.split('.');
  const name = parts.length > 1 ? parts.slice(1).join('.') : param;

  // Convert to title case
  return name
    .split(/[.-]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
