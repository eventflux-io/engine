import { useState, useMemo } from 'react';
import { Settings, ChevronDown, ChevronRight, Copy, Check, ArrowDownToLine, ArrowUpFromLine, Table2, Edit2 } from 'lucide-react';
import { useApplicationStore } from '../../stores/applicationStore';

interface ConfiguredElement {
  id: string;
  name: string;
  type: 'source' | 'sink' | 'extension';
  connectorType: string;
  config: Record<string, string>;
  nodeId: string;
}

export function ConfigPanel() {
  const { nodes, updateElement } = useApplicationStore();
  const [copied, setCopied] = useState(false);
  const [expandedSections, setExpandedSections] = useState<Set<string>>(new Set(['sources', 'sinks', 'extensions']));
  const [editingConfig, setEditingConfig] = useState<string | null>(null);

  // Extract all configured elements - now from Source and Sink nodes directly
  const configuredElements = useMemo((): ConfiguredElement[] => {
    const elements: ConfiguredElement[] = [];

    for (const node of nodes) {
      const data = node.data as Record<string, unknown>;

      // Source nodes (external data ingestion)
      if (node.type === 'source') {
        elements.push({
          id: `source-${node.id}`,
          name: (data.sourceName as string) || 'Unnamed Source',
          type: 'source',
          connectorType: (data.sourceType as string) || 'kafka',
          config: (data.config as Record<string, string>) || {},
          nodeId: node.id,
        });
      }

      // Sink nodes (external data output)
      if (node.type === 'sink') {
        elements.push({
          id: `sink-${node.id}`,
          name: (data.sinkName as string) || 'Unnamed Sink',
          type: 'sink',
          connectorType: (data.sinkType as string) || 'log',
          config: (data.config as Record<string, string>) || {},
          nodeId: node.id,
        });
      }

      // Tables with extensions
      if (node.type === 'table' && data.extension) {
        elements.push({
          id: `extension-${node.id}`,
          name: (data.tableName as string) || 'Unnamed Table',
          type: 'extension',
          connectorType: data.extension as string,
          config: (data.withConfig as Record<string, string>) || {},
          nodeId: node.id,
        });
      }
    }

    return elements;
  }, [nodes]);

  const sources = configuredElements.filter((e) => e.type === 'source');
  const sinks = configuredElements.filter((e) => e.type === 'sink');
  const extensions = configuredElements.filter((e) => e.type === 'extension');

  // Update config for an element
  const handleConfigUpdate = (element: ConfiguredElement, key: string, value: string) => {
    const node = nodes.find((n) => n.id === element.nodeId);
    if (!node) return;

    const data = node.data as Record<string, unknown>;
    // Source and Sink nodes use 'config', Tables use 'withConfig'
    const configKey = element.type === 'extension' ? 'withConfig' : 'config';

    const currentConfig = (data[configKey] as Record<string, string>) || {};
    updateElement(element.nodeId, {
      data: {
        ...data,
        [configKey]: { ...currentConfig, [key]: value },
      },
    });
  };

  // Generate TOML configuration
  const generateTOML = (): string => {
    const lines: string[] = [];
    lines.push('# EventFlux Application Configuration');
    lines.push('# Generated by EventFlux Studio');
    lines.push('');

    // Application metadata
    lines.push('[application]');
    lines.push(`name = "EventFluxApp"`);
    lines.push('');

    // Sources section
    if (sources.length > 0) {
      lines.push('# Source Connectors');
      for (const source of sources) {
        lines.push(`[sources.${source.connectorType}.${source.name}]`);
        lines.push(`stream = "${source.name}"`);
        for (const [k, v] of Object.entries(source.config)) {
          const formattedValue = /^\d+$/.test(v) ? v : `"${v}"`;
          lines.push(`${k} = ${formattedValue}`);
        }
        lines.push('');
      }
    }

    // Sinks section
    if (sinks.length > 0) {
      lines.push('# Sink Connectors');
      for (const sink of sinks) {
        lines.push(`[sinks.${sink.connectorType}.${sink.name}]`);
        lines.push(`stream = "${sink.name}"`);
        for (const [k, v] of Object.entries(sink.config)) {
          const formattedValue = /^\d+$/.test(v) ? v : `"${v}"`;
          lines.push(`${k} = ${formattedValue}`);
        }
        lines.push('');
      }
    }

    // Extensions section
    if (extensions.length > 0) {
      lines.push('# Table Extensions');
      for (const ext of extensions) {
        lines.push(`[extensions.${ext.connectorType}.${ext.name}]`);
        for (const [k, v] of Object.entries(ext.config)) {
          const formattedValue = /^\d+$/.test(v) ? v : `"${v}"`;
          lines.push(`${k} = ${formattedValue}`);
        }
        lines.push('');
      }
    }

    return lines.join('\n');
  };

  const handleCopyTOML = () => {
    navigator.clipboard.writeText(generateTOML());
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const toggleSection = (section: string) => {
    setExpandedSections((prev) => {
      const next = new Set(prev);
      if (next.has(section)) {
        next.delete(section);
      } else {
        next.add(section);
      }
      return next;
    });
  };

  const hasConfig = sources.length > 0 || sinks.length > 0 || extensions.length > 0;

  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div className="px-3 py-2 border-b border-vscode-border flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Settings className="w-4 h-4 text-gray-400" />
          <span className="text-sm font-medium text-gray-300">Configuration</span>
        </div>
        <button
          onClick={handleCopyTOML}
          className="p-1 text-gray-400 hover:text-white transition-colors"
          title="Copy TOML to clipboard"
          disabled={!hasConfig}
        >
          {copied ? <Check className="w-4 h-4 text-green-400" /> : <Copy className="w-4 h-4" />}
        </button>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        {!hasConfig ? (
          <div className="p-4 text-sm text-gray-500 text-center">
            <p className="mb-3">No connectors configured yet.</p>
            <div className="text-xs space-y-2 text-left bg-gray-800/50 p-3 rounded">
              <p><strong>To add configuration:</strong></p>
              <p>1. Select a <span className="text-blue-400">Stream</span> and choose a Source Connector</p>
              <p>2. Select a <span className="text-purple-400">Table</span> and choose an Extension</p>
              <p>3. Select an <span className="text-green-400">Output</span> and choose a Sink Connector</p>
            </div>
          </div>
        ) : (
          <div className="p-2 space-y-2">
            {/* Sources */}
            {sources.length > 0 && (
              <ConfigSection
                title="Source Connectors"
                icon={<ArrowDownToLine className="w-4 h-4 text-green-400" />}
                expanded={expandedSections.has('sources')}
                onToggle={() => toggleSection('sources')}
              >
                {sources.map((source) => (
                  <ConfigElementCard
                    key={source.id}
                    element={source}
                    isEditing={editingConfig === source.id}
                    onToggleEdit={() => setEditingConfig(editingConfig === source.id ? null : source.id)}
                    onConfigChange={(key, value) => handleConfigUpdate(source, key, value)}
                  />
                ))}
              </ConfigSection>
            )}

            {/* Sinks */}
            {sinks.length > 0 && (
              <ConfigSection
                title="Sink Connectors"
                icon={<ArrowUpFromLine className="w-4 h-4 text-purple-400" />}
                expanded={expandedSections.has('sinks')}
                onToggle={() => toggleSection('sinks')}
              >
                {sinks.map((sink) => (
                  <ConfigElementCard
                    key={sink.id}
                    element={sink}
                    isEditing={editingConfig === sink.id}
                    onToggleEdit={() => setEditingConfig(editingConfig === sink.id ? null : sink.id)}
                    onConfigChange={(key, value) => handleConfigUpdate(sink, key, value)}
                  />
                ))}
              </ConfigSection>
            )}

            {/* Extensions */}
            {extensions.length > 0 && (
              <ConfigSection
                title="Table Extensions"
                icon={<Table2 className="w-4 h-4 text-violet-400" />}
                expanded={expandedSections.has('extensions')}
                onToggle={() => toggleSection('extensions')}
              >
                {extensions.map((ext) => (
                  <ConfigElementCard
                    key={ext.id}
                    element={ext}
                    isEditing={editingConfig === ext.id}
                    onToggleEdit={() => setEditingConfig(editingConfig === ext.id ? null : ext.id)}
                    onConfigChange={(key, value) => handleConfigUpdate(ext, key, value)}
                  />
                ))}
              </ConfigSection>
            )}

            {/* TOML Preview */}
            <div className="mt-4 pt-3 border-t border-gray-700">
              <div className="text-xs text-gray-400 mb-2 flex items-center justify-between">
                <span>Generated TOML</span>
              </div>
              <pre className="text-xs bg-gray-900/70 p-2 rounded border border-gray-700 overflow-x-auto font-mono text-gray-400 whitespace-pre-wrap max-h-40">
                {generateTOML()}
              </pre>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// Section component for grouping config items
function ConfigSection({
  title,
  icon,
  expanded,
  onToggle,
  children,
}: {
  title: string;
  icon: React.ReactNode;
  expanded: boolean;
  onToggle: () => void;
  children: React.ReactNode;
}) {
  return (
    <div className="bg-gray-800/30 rounded">
      <button
        onClick={onToggle}
        className="w-full flex items-center gap-2 px-3 py-2 hover:bg-gray-800/50 transition-colors text-left"
      >
        {expanded ? (
          <ChevronDown className="w-3 h-3 text-gray-500" />
        ) : (
          <ChevronRight className="w-3 h-3 text-gray-500" />
        )}
        {icon}
        <span className="text-xs font-medium text-gray-300">{title}</span>
      </button>
      {expanded && <div className="px-2 pb-2 space-y-2">{children}</div>}
    </div>
  );
}

// Card for individual config element
function ConfigElementCard({
  element,
  isEditing,
  onToggleEdit,
  onConfigChange,
}: {
  element: ConfiguredElement;
  isEditing: boolean;
  onToggleEdit: () => void;
  onConfigChange: (key: string, value: string) => void;
}) {
  const connectorLabels: Record<string, string> = {
    kafka: 'Kafka',
    http: 'HTTP',
    mqtt: 'MQTT',
    file: 'File',
    log: 'Log',
    redis: 'Redis',
    jdbc: 'JDBC',
  };

  return (
    <div className="bg-gray-800/50 rounded p-2">
      <div className="flex items-center justify-between mb-1">
        <div className="flex items-center gap-2">
          <span className="text-xs font-medium text-gray-200">{element.name}</span>
          <span className="text-xs px-1.5 py-0.5 bg-gray-700 rounded text-gray-400">
            {connectorLabels[element.connectorType] || element.connectorType}
          </span>
        </div>
        <button
          onClick={onToggleEdit}
          className={`p-1 transition-colors ${
            isEditing ? 'text-indigo-400' : 'text-gray-500 hover:text-gray-300'
          }`}
          title={isEditing ? 'Done editing' : 'Edit configuration'}
        >
          <Edit2 className="w-3 h-3" />
        </button>
      </div>

      {/* Config display/edit */}
      <div className="space-y-1">
        {Object.entries(element.config).map(([key, value]) => (
          <div key={key} className="flex items-center gap-1 text-xs">
            <span className="text-gray-500 w-24 truncate" title={key}>{key}:</span>
            {isEditing ? (
              <input
                type="text"
                value={value}
                onChange={(e) => onConfigChange(key, e.target.value)}
                className="flex-1 px-1.5 py-0.5 bg-gray-900 border border-gray-600 rounded text-gray-300 text-xs"
              />
            ) : (
              <span className="text-gray-300 truncate flex-1" title={value}>{value || '(empty)'}</span>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}
