// Minimal Siddhi grammar using LALRPOP
// Supports stream/table/query definitions used in tests

grammar;

use crate::query_api::definition::{StreamDefinition, TableDefinition, AggregationDefinition, WindowDefinition};
use crate::query_api::definition::attribute::Type as AttributeType;
use crate::query_api::definition::attribute::Attribute;
use crate::query_api::execution::query::input::handler::WindowHandler;
use crate::query_api::execution::query::{Query, OnDemandQuery, StoreQuery, OnDemandQueryType};
use crate::query_api::execution::query::selection::Selector;
use crate::query_api::execution::query::output::output_stream::{
    OutputStream,
    OutputStreamAction,
    InsertIntoStreamAction,
    UpdateStreamAction,
    DeleteStreamAction,
};
use crate::query_api::execution::query::input::{
    InputStream, SingleInputStream, JoinType, StateInputStreamType, StateElement, State,
};
use crate::query_api::execution::query::input::store::{InputStore, Store, ConditionInputStore, AggregationInputStore};
use crate::query_api::aggregation::Within;
use crate::query_api::expression::{Expression, variable::Variable};
use crate::query_api::expression::condition::compare::Operator as CompareOperator;
use crate::query_api::aggregation::TimePeriod;
use crate::query_api::aggregation::time_period::Duration as TimeDuration;
use crate::query_api::annotation::Annotation;
use crate::query_api::execution::{
    Partition, PartitionType, RangePartitionProperty, RangePartitionType,
    ValuePartitionType,
};

pub AnnotationStmt: Annotation = {
    "@" <name:Ident> ":" <key:Ident> "(" <val:STRING> ")" => {
        Annotation::new(name).element(Some(key), val)
    } 
};

pub OnDemandQueryStmt: OnDemandQuery = {
    "from" <st:InputStoreRule> "select" <sel:SelectList> => {
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        OnDemandQuery::query()
            .from(st)
            .select(selector)
            .set_type(OnDemandQueryType::Find)
    }
};

pub StoreQueryStmt: StoreQuery = { <q:OnDemandQueryStmt> => StoreQuery::new(q) };

Annotations: Vec<Annotation> = {
    <first:AnnotationStmt> <rest:AnnotationStmt*> => {
        let mut v = vec![first];
        for a in rest { v.push(a); }
        v
    },
    => Vec::new(),
};


pub StreamDef: StreamDefinition = {
    "define" "stream" <id:Ident> "(" <attrs:AttrList> ")" => {
        let mut d = StreamDefinition::new(id);
        for (n,t) in attrs { d = d.attribute(n, t); }
        d
    }
};

pub TableDef: TableDefinition = {
    "define" "table" <id:Ident> "(" <attrs:AttrList> ")" => {
        let mut d = TableDefinition::new(id);
        for (n,t) in attrs { d = d.attribute(n, t); }
        d
    }
};

pub WindowParam: WindowHandler = {
    <name:Ident> "(" <args:ExprList> ")" => WindowHandler::new(name, None, args),
};

WindowParamOpt: Option<WindowHandler> = {
    <p:WindowParam> => Some(p),
    => None,
};

pub WindowDef: WindowDefinition = {
    "define" "window" <id:Ident> "(" <attrs:AttrList> ")" <param:WindowParamOpt> => {
        let mut d = WindowDefinition::new(id);
        for (n, t) in attrs {
            d.stream_definition.abstract_definition.attribute_list.push(Attribute::new(n, t));
        }
        if let Some(w) = param { d = d.window(w); }
        d
    }
};

pub AggDef: AggregationDefinition = {
    "define" "aggregation" <id:Ident> "from" <in_id:Ident> "select" <sel:SelectList> "group" "by" <grp:Ident> "aggregate" "every" <durs:DurationList> => {
        let mut agg = AggregationDefinition::new(id);
        let input_stream = crate::query_api::execution::query::input::InputStream::stream(in_id.clone());
        let single = match input_stream { crate::query_api::execution::query::input::InputStream::Single(s) => s, _ => unreachable!() };
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        let period = TimePeriod::interval(durs);
        agg.from(single).select(selector).aggregate_by(Variable::new(grp)).every(period)
    }
};

InputStreamRule: InputStream = {
    <id:Ident> "[" <cond:Expression> "]" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).filter(cond);
        InputStream::Single(si)
    },
    <id:Ident> "#" <wname:Ident> "(" <wargs:ExprList> ")" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).window(None, wname, wargs);
        InputStream::Single(si)
    },
    <id:Ident> => InputStream::stream(id),
    <left:Ident> "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::Join,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },
    <left:Ident> "inner" "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::InnerJoin,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },
    <left:Ident> "left" "outer" "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::LeftOuterJoin,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },
    <left:Ident> "right" "outer" "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::RightOuterJoin,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },
    <left:Ident> "full" "outer" "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::FullOuterJoin,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },

    <start:Unit> "->" <next:Unit> <rest:("->" Unit)*> => {
        let mut st = State::next(start, next);
        for (_, u) in rest { st = State::next(st, u); }
        InputStream::pattern_stream(st, None)
    },
    <start:Unit> "," <next:Unit> <rest:("," Unit)*> => {
        let mut st = State::next(start, next);
        for (_, u) in rest { st = State::next(st, u); }
        InputStream::sequence_stream(st, None)
    },
};

InputStoreRule: InputStore = {
    <id:Ident> "on" <cond:Expression> "within" <within_expr:Expression> "per" <per_expr:Expression> => {
        let store = Store::new_with_id(id);
        let within = Within::new_with_pattern(within_expr);
        InputStore::Aggregation(Box::new(AggregationInputStore::new_with_condition(store, cond, within, per_expr)))
    },
    <id:Ident> "on" <cond:Expression> => {
        let store = Store::new_with_id(id);
        InputStore::Condition(Box::new(ConditionInputStore::new(store, cond)))
    },
    <id:Ident> => InputStore::Store(Store::new_with_id(id)),
};

Unit: StateElement = {
    "every" <u:BasicUnit> => State::every(u),
    <u:BasicUnit> => u,
};

BasicUnit: StateElement = {
    <alias:Ident> "=" <id:Ident> "[" <cond:Expression> "]" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).filter(cond).as_ref(alias);
        State::stream_element(si)
    },
    <alias:Ident> "=" <id:Ident> "#" <wname:Ident> "(" <wargs:ExprList> ")" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).window(None, wname, wargs).as_ref(alias);
        State::stream_element(si)
    },
    <alias:Ident> "=" <id:Ident> => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).as_ref(alias);
        State::stream_element(si)
    },
    <id:Ident> "[" <cond:Expression> "]" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).filter(cond);
        State::stream_element(si)
    },
    <id:Ident> "#" <wname:Ident> "(" <wargs:ExprList> ")" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).window(None, wname, wargs);
        State::stream_element(si)
    },
    <id:Ident> => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new());
        State::stream_element(si)
    },
};

pub QueryStmt: Query = {
    // INSERT INTO <stream/table>
    "from" <istream:InputStreamRule> "select" <sel:SelectList> "insert" "into" "table" <out_id:Ident> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        let insert_action = InsertIntoStreamAction { target_id: out_id, is_inner_stream: false, is_fault_stream: false };
        let output_stream = OutputStream::new(OutputStreamAction::InsertInto(insert_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    "from" <istream:InputStreamRule> "select" <sel:SelectList> "insert" "into" <out_id:Ident> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        let insert_action = InsertIntoStreamAction { target_id: out_id, is_inner_stream: false, is_fault_stream: false };
        let output_stream = OutputStream::new(OutputStreamAction::InsertInto(insert_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    // UPDATE TABLE
    "from" <istream:InputStreamRule> "select" <sel:SelectList> "update" "table" <t_id:Ident> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        let update_action = UpdateStreamAction { target_id: t_id, on_update_expression: Expression::value_bool(true), update_set_clause: None };
        let output_stream = OutputStream::new(OutputStreamAction::Update(update_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    // DELETE FROM TABLE
    "from" <istream:InputStreamRule> "select" <sel:SelectList> "delete" "table" <t_id:Ident> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        let delete_action = DeleteStreamAction { target_id: t_id, on_delete_expression: Expression::value_bool(true) };
        let output_stream = OutputStream::new(OutputStreamAction::Delete(delete_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    }
};


pub PartitionStmt: Partition = {
    "partition" "with" "(" <first:PartitionWithStream> <rest:("," PartitionWithStream)*> ")" "begin" <qs:QueryList> "end" => {
        let mut p = Partition::partition().with_partition_type(first);
        for (_, pt) in rest { p = p.with_partition_type(pt); }
        for q in qs { p = p.add_query(q); }
        p
    }
};

QueryList: Vec<Query> = {
    <first:QueryStmt> <rest:(";" QueryStmt)*> ";"? => {
        let mut v = vec![first];
        for (_, q) in rest { v.push(q); }
        v
    }
};

PartitionWithStream: PartitionType = {
    <expr:Expression> "of" <sid:Ident> => PartitionType::new_value(ValuePartitionType::new(sid, expr)),
    <cr:ConditionRanges> "of" <sid:Ident> => PartitionType::new_range(RangePartitionType::new(sid, cr)),
};

ConditionRanges: Vec<RangePartitionProperty> = {
    <first:ConditionRange> <rest:("or" ConditionRange)*> => {
        let mut v = vec![first];
        for (_, c) in rest { v.push(c); }
        v
    }
};

ConditionRange: RangePartitionProperty = { <expr:Expression> "as" <key:STRING> => RangePartitionProperty::new(key, expr) };


SelectList: Vec<(Expression, Option<String>)> = {
    <first:SelectItem> <rest:("," SelectItem)*> => {
        let mut v = vec![first];
        for (_, a) in rest { v.push(a); }
        v
    },
    => Vec::new()
};

SelectItem: (Expression, Option<String>) = {
    <e:Expression> "as" <a:Ident> => (e, Some(a)),
    <e:Expression> => (e, None),
};

AttrList: Vec<(String, AttributeType)> = {
    <first:Attribute> <rest:("," Attribute)*> => {
        let mut v = vec![first];
        for (_, a) in rest { v.push(a); }
        v
    },
    => Vec::new()
};

Attribute: (String, AttributeType) = { <name:Ident> <ty:Type> => (name, ty) };

DurationList: Vec<TimeDuration> = {
    <first:Duration> <rest:("," Duration)*> => {
        let mut v = vec![first];
        for (_, d) in rest { v.push(d); }
        v
    },
    => Vec::new()
};

Duration: TimeDuration = {
    "seconds" => TimeDuration::Seconds,
    "minutes" => TimeDuration::Minutes,
    "hours" => TimeDuration::Hours,
    "days" => TimeDuration::Days,
    "months" => TimeDuration::Months,
    "years" => TimeDuration::Years,
};

Type: AttributeType = {
    "string" => AttributeType::STRING,
    "int" => AttributeType::INT,
    "long" => AttributeType::LONG,
    "float" => AttributeType::FLOAT,
    "double" => AttributeType::DOUBLE,
    "bool" => AttributeType::BOOL,
    "boolean" => AttributeType::BOOL,
    "object" => AttributeType::OBJECT,
};

pub Expression: Expression = { <e:OrExpr> => e };

OrExpr: Expression = {
    <l:OrExpr> "or" <r:AndExpr> => Expression::or(l, r),
    <e:AndExpr> => e,
};

AndExpr: Expression = {
    <l:AndExpr> "and" <r:NotExpr> => Expression::and(l, r),
    <e:NotExpr> => e,
};

NotExpr: Expression = {
    "not" <e:NotExpr> => Expression::not(e),
    <e:CompareExpr> => e,
};

CompareExpr: Expression = {
    <l:AddExpr> ">=" <r:AddExpr> => Expression::compare(l, CompareOperator::GreaterThanEqual, r),
    <l:AddExpr> "<=" <r:AddExpr> => Expression::compare(l, CompareOperator::LessThanEqual, r),
    <l:AddExpr> ">" <r:AddExpr> => Expression::compare(l, CompareOperator::GreaterThan, r),
    <l:AddExpr> "<" <r:AddExpr> => Expression::compare(l, CompareOperator::LessThan, r),
    <l:AddExpr> "==" <r:AddExpr> => Expression::compare(l, CompareOperator::Equal, r),
    <l:AddExpr> "!=" <r:AddExpr> => Expression::compare(l, CompareOperator::NotEqual, r),
    <e:AddExpr> => e,
};

AddExpr: Expression = {
    <l:AddExpr> "+" <r:MulExpr> => Expression::add(l, r),
    <l:AddExpr> "-" <r:MulExpr> => Expression::subtract(l, r),
    <e:MulExpr> => e,
};

MulExpr: Expression = {
    <l:MulExpr> "*" <r:PrimaryExpr> => Expression::multiply(l, r),
    <l:MulExpr> "/" <r:PrimaryExpr> => Expression::divide(l, r),
    <e:PrimaryExpr> => e,
};

PrimaryExpr: Expression = {
    "(" <e:Expression> ")" => e,
    <s:STRING> => Expression::value_string(s),
    <n:NUMBER> => Expression::value_long(n),
    "-" <n:NUMBER> => Expression::value_long(-n),
    <sid:Ident> "." <id:Ident> => Expression::Variable(Variable::new(id).of_stream(sid)),
    <ns:Ident> ":" <id:Ident> "(" <args:ExprList> ")" => Expression::function(Some(ns), id, args),
    <id:Ident> "(" <args:ExprList> ")" => Expression::function_no_ns(id, args),
    <id:Ident> => Expression::variable(id),
};

ExprList: Vec<Expression> = {
    <first:Expression> <rest:("," Expression)*> => {
        let mut v = vec![first];
        for (_, e) in rest { v.push(e); }
        v
    },
    => Vec::new()
};

Ident: String = { <r"[A-Za-z_][A-Za-z0-9_]*"> => <>.to_string() };

STRING: String = {
    <r#"'([^']*)'"#> => { let s = <>; s[1..s.len()-1].to_string() },
    <r#"\"([^\"]*)\""#> => { let s = <>; s[1..s.len()-1].to_string() },
};

NUMBER: i64 = { <r"[0-9]+"> => <>.parse().unwrap() };

