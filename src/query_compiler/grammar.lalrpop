// Minimal Siddhi grammar using LALRPOP
// Supports stream/table/query definitions used in tests

grammar;

use crate::query_api::definition::{
    StreamDefinition,
    TableDefinition,
    AggregationDefinition,
    WindowDefinition,
    FunctionDefinition,
    TriggerDefinition,
};
use crate::query_api::definition::attribute::Type as AttributeType;
use crate::query_api::definition::attribute::Attribute;
use crate::query_api::execution::query::input::handler::WindowHandler;
use crate::query_api::execution::query::{Query, OnDemandQuery, StoreQuery, OnDemandQueryType};
use crate::query_api::execution::query::selection::Selector;
use crate::query_api::execution::query::selection::order_by_attribute::{OrderByAttribute, Order as OrderByOrder};
use crate::query_api::expression::constant::Constant;
use crate::query_api::expression::constant::TimeUtil;
use crate::query_api::execution::query::output::output_stream::{
    OutputStream,
    OutputStreamAction,
    InsertIntoStreamAction,
    UpdateStreamAction,
    UpdateOrInsertStreamAction,
    DeleteStreamAction,
};
use crate::query_api::execution::query::output::stream::UpdateSet;
use crate::query_api::execution::query::input::{
    InputStream, SingleInputStream, JoinType, StateInputStreamType, StateElement, State,
};
use crate::query_api::execution::query::input::store::{InputStore, Store, ConditionInputStore, AggregationInputStore};
use crate::query_api::aggregation::Within;
use crate::query_api::expression::{Expression, variable::Variable};
use crate::query_api::expression::condition::compare::Operator as CompareOperator;
use crate::query_api::aggregation::TimePeriod;
use crate::query_api::aggregation::time_period::Duration as TimeDuration;
use crate::query_api::annotation::Annotation;
use crate::query_api::execution::{
    Partition, PartitionType, RangePartitionProperty, RangePartitionType,
    ValuePartitionType,
};

pub AnnotationStmt: Annotation = {
    "@" <name:Ident> "(" <pairs:KeyValuePairs> ")" => {
        let mut a = Annotation::new(name);
        for (k, v) in pairs { a = a.element(Some(k), v); }
        a
    },
    "@" <name:Ident> ":" <key:Ident> "(" <val:STRING> ")" => {
        Annotation::new(name).element(Some(key), val)
    }
};

KeyValuePairs: Vec<(String, String)> = {
    <first:KeyValue> <rest:("," KeyValue)*> => {
        let mut v = vec![first];
        for (_, kv) in rest { v.push(kv); }
        v
    },
    => Vec::new(),
};

KeyValue: (String, String) = { <k:Ident> "=" <v:STRING> => (k, v) };

pub OnDemandQueryStmt: OnDemandQuery = {
    "from" <st:InputStoreRule> <sel:QuerySection> => {
        OnDemandQuery::query()
            .from(st)
            .select(sel)
            .set_type(OnDemandQueryType::Find)
    },
    "delete" <t:Ident> "on" <cond:Expression> => {
        OnDemandQuery::query()
            .delete_by(t, cond)
            .set_type(OnDemandQueryType::Delete)
    },
    "update" <t:Ident> <set:SetClauseOpt> "on" <cond:Expression> => {
        match set {
            Some(s) => OnDemandQuery::query()
                .update_by_with_set(t, s, cond)
                .set_type(OnDemandQueryType::Update),
            None => OnDemandQuery::query()
                .update_by(t, cond)
                .set_type(OnDemandQueryType::Update),
        }
    },
    "update" "or" "insert" "into" <t:Ident> <set:SetClauseOpt> "on" <cond:Expression> => {
        OnDemandQuery::query()
            .update_or_insert_by(t, set.unwrap_or_else(UpdateSet::new), cond)
            .set_type(OnDemandQueryType::UpdateOrInsert)
    }
};

QuerySection: Selector = {
    "select" <sel:SelectList> <grp:GroupByOpt> <hav:HavingOpt> <ord:OrderByOpt> <lim:LimitOpt> <off:OffsetOpt> => {
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        for v in grp { selector = selector.group_by(v); }
        if let Some(h) = hav { selector = selector.having(h); }
        for ob in ord { selector = selector.order_by_with_order(ob.variable.clone(), ob.order); }
        if let Some(l) = lim { selector = selector.limit(l).unwrap(); }
        if let Some(o) = off { selector = selector.offset(o).unwrap(); }
        selector
    }
};

VariableRef: Variable = {
    <sid:Ident> "." <id:Ident> => Variable::new(id).of_stream(sid),
    <id:Ident> => Variable::new(id),
};

SetAssignment: (Variable, Expression) = {
    <var:VariableRef> "=" <expr:Expression> => (var, expr),
};

pub SetClause: UpdateSet = {
    "set" <first:SetAssignment> <rest:("," SetAssignment)*> => {
        let mut us = UpdateSet::new().add_set_attribute(first.0, first.1);
        for (_, (v, e)) in rest { us = us.add_set_attribute(v, e); }
        us
    }
};

SetClauseOpt: Option<UpdateSet> = {
    <s:SetClause> => Some(s),
    => None,
};

pub StoreQueryStmt: StoreQuery = { <q:OnDemandQueryStmt> => StoreQuery::new(q) };

Annotations: Vec<Annotation> = {
    <first:AnnotationStmt> <rest:AnnotationStmt*> => {
        let mut v = vec![first];
        for a in rest { v.push(a); }
        v
    },
    => Vec::new(),
};


pub StreamDef: StreamDefinition = {
    <ann:Annotations> "define" "stream" <id:Ident> "(" <attrs:AttrList> ")" => {
        let mut d = StreamDefinition::new(id);
        for (n,t) in attrs { d = d.attribute(n, t); }
        for a in ann { d = d.annotation(a); }
        d
    }
};

pub TableDef: TableDefinition = {
    <ann:Annotations> "define" "table" <id:Ident> "(" <attrs:AttrList> ")" => {
        let mut d = TableDefinition::new(id);
        for (n,t) in attrs { d = d.attribute(n, t); }
        for a in ann { d = d.annotation(a); }
        d
    }
};

pub WindowParam: WindowHandler = {
    <name:Ident> "(" <args:ExprList> ")" => WindowHandler::new(name, None, args),
};

WindowParamOpt: Option<WindowHandler> = {
    <p:WindowParam> => Some(p),
    => None,
};

pub WindowDef: WindowDefinition = {
    <ann:Annotations> "define" "window" <id:Ident> "(" <attrs:AttrList> ")" <param:WindowParamOpt> => {
        let mut d = WindowDefinition::new(id);
        for (n, t) in attrs {
            d.stream_definition.abstract_definition.attribute_list.push(Attribute::new(n, t));
        }
        if let Some(w) = param { d = d.window(w); }
        for a in ann { d = d.annotation(a); }
        d
    }
};

pub FunctionDef: FunctionDefinition = {
    <ann:Annotations> "define" "function" <id:Ident> "[" <lang:Ident> "]" "return" <ty:Type> <body:STRING> => {
        let mut d = FunctionDefinition::new(id, lang, body, ty);
        for a in ann { d = d.annotation(a); }
        d
    }
};

pub TriggerDef: TriggerDefinition = {
    <ann:Annotations> "define" "trigger" <id:Ident> "at" "every" <dur:TimeConstant> => {
        let mut d = TriggerDefinition::id(id).at_every_time_constant(dur).unwrap();
        for a in ann { d = d.annotation(a); }
        d
    },
    <ann:Annotations> "define" "trigger" <id:Ident> "at" <expr:STRING> => {
        let mut d = TriggerDefinition::id(id).at(expr);
        for a in ann { d = d.annotation(a); }
        d
    }
};

pub AggDef: AggregationDefinition = {
    <ann:Annotations> "define" "aggregation" <id:Ident> "from" <in_id:Ident> "select" <sel:SelectList> "group" "by" <grp:Ident> "aggregate" "every" <durs:DurationList> => {
        let mut agg = AggregationDefinition::new(id);
        let input_stream = crate::query_api::execution::query::input::InputStream::stream(in_id.clone());
        let single = match input_stream { crate::query_api::execution::query::input::InputStream::Single(s) => s, _ => unreachable!() };
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        let period = TimePeriod::interval(durs);
        for a in ann { agg = agg.annotation(a); }
        agg.from(single).select(selector).aggregate_by(Variable::new(grp)).every(period)
    }
};

InputStreamRule: InputStream = {
    <id:Ident> "[" <cond:Expression> "]" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).filter(cond);
        InputStream::Single(si)
    },
    <id:Ident> "#" <wname:Ident> "(" <wargs:ExprList> ")" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).window(None, wname, wargs);
        InputStream::Single(si)
    },
    <id:Ident> "on" <_cond:Expression> "within" <_within:Expression> "per" <_per:Expression> => InputStream::stream(id),
    <id:Ident> => InputStream::stream(id),
    <left:Ident> "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::Join,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },
    <left:Ident> "inner" "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::InnerJoin,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },
    <left:Ident> "left" "outer" "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::LeftOuterJoin,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },
    <left:Ident> "right" "outer" "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::RightOuterJoin,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },
    <left:Ident> "full" "outer" "join" <right:Ident> "on" <cond:Expression> => {
        InputStream::join_stream(
            SingleInputStream::new_basic(left, false, false, None, Vec::new()),
            JoinType::FullOuterJoin,
            SingleInputStream::new_basic(right, false, false, None, Vec::new()),
            Some(cond),
            None,
            None,
            None,
        )
    },

    <start:Unit> "->" <next:Unit> <rest:("->" Unit)*> => {
        let mut st = State::next(start, next);
        for (_, u) in rest { st = State::next(st, u); }
        InputStream::pattern_stream(st, None)
    },
    <start:Unit> "," <next:Unit> <rest:("," Unit)*> => {
        let mut st = State::next(start, next);
        for (_, u) in rest { st = State::next(st, u); }
        InputStream::sequence_stream(st, None)
    },
};

InputStoreRule: InputStore = {
    <id:Ident> "on" <cond:Expression> "within" <within_expr:Expression> "per" <per_expr:Expression> => {
        let store = Store::new_with_id(id);
        let within = Within::new_with_pattern(within_expr);
        InputStore::Aggregation(Box::new(AggregationInputStore::new_with_condition(store, cond, within, per_expr)))
    },
    <id:Ident> "on" <cond:Expression> => {
        let store = Store::new_with_id(id);
        InputStore::Condition(Box::new(ConditionInputStore::new(store, cond)))
    },
    <id:Ident> => InputStore::Store(Store::new_with_id(id)),
};

Unit: StateElement = {
    "every" <u:BasicUnit> => State::every(u),
    <u:BasicUnit> => u,
};

BasicUnit: StateElement = {
    <alias:Ident> "=" <id:Ident> "[" <cond:Expression> "]" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).filter(cond).as_ref(alias);
        State::stream_element(si)
    },
    <alias:Ident> "=" <id:Ident> "#" <wname:Ident> "(" <wargs:ExprList> ")" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).window(None, wname, wargs).as_ref(alias);
        State::stream_element(si)
    },
    <alias:Ident> "=" <id:Ident> => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).as_ref(alias);
        State::stream_element(si)
    },
    <id:Ident> "[" <cond:Expression> "]" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).filter(cond);
        State::stream_element(si)
    },
    <id:Ident> "#" <wname:Ident> "(" <wargs:ExprList> ")" => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new()).window(None, wname, wargs);
        State::stream_element(si)
    },
    <id:Ident> => {
        let si = SingleInputStream::new_basic(id, false, false, None, Vec::new());
        State::stream_element(si)
    },
};

pub QueryStmt: Query = {
    // INSERT INTO <stream/table>
    "from" <istream:InputStreamRule> "select" <sel:SelectList> <grp:GroupByOpt> <hav:HavingOpt> <ord:OrderByOpt> <lim:LimitOpt> <off:OffsetOpt> "insert" "into" "table" <out_id:Ident> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        for v in grp { selector = selector.group_by(v); }
        if let Some(h) = hav { selector = selector.having(h); }
        for ob in ord { selector = selector.order_by_with_order(ob.variable.clone(), ob.order); }
        if let Some(l) = lim { selector = selector.limit(l).unwrap(); }
        if let Some(o) = off { selector = selector.offset(o).unwrap(); }
        let insert_action = InsertIntoStreamAction { target_id: out_id, is_inner_stream: false, is_fault_stream: false };
        let output_stream = OutputStream::new(OutputStreamAction::InsertInto(insert_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    "from" <istream:InputStreamRule> "select" <sel:SelectList> <grp:GroupByOpt> <hav:HavingOpt> <ord:OrderByOpt> <lim:LimitOpt> <off:OffsetOpt> "insert" "into" <out_id:Ident> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        for v in grp { selector = selector.group_by(v); }
        if let Some(h) = hav { selector = selector.having(h); }
        for ob in ord { selector = selector.order_by_with_order(ob.variable.clone(), ob.order); }
        if let Some(l) = lim { selector = selector.limit(l).unwrap(); }
        if let Some(o) = off { selector = selector.offset(o).unwrap(); }
        let insert_action = InsertIntoStreamAction { target_id: out_id, is_inner_stream: false, is_fault_stream: false };
        let output_stream = OutputStream::new(OutputStreamAction::InsertInto(insert_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    // UPDATE TABLE with ON condition
    "from" <istream:InputStreamRule> "select" <sel:SelectList> <grp:GroupByOpt> <hav:HavingOpt> <ord:OrderByOpt> <lim:LimitOpt> <off:OffsetOpt> "update" <t_id:Ident> <set:SetClauseOpt> "on" <cond:Expression> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        for v in grp { selector = selector.group_by(v); }
        if let Some(h) = hav { selector = selector.having(h); }
        for ob in ord { selector = selector.order_by_with_order(ob.variable.clone(), ob.order); }
        if let Some(l) = lim { selector = selector.limit(l).unwrap(); }
        if let Some(o) = off { selector = selector.offset(o).unwrap(); }
        let update_action = UpdateStreamAction { target_id: t_id, on_update_expression: cond, update_set_clause: set };
        let output_stream = OutputStream::new(OutputStreamAction::Update(update_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    // Legacy UPDATE TABLE syntax
    "from" <istream:InputStreamRule> "select" <sel:SelectList> <grp:GroupByOpt> <hav:HavingOpt> <ord:OrderByOpt> <lim:LimitOpt> <off:OffsetOpt> "update" "table" <t_id:Ident> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        for v in grp { selector = selector.group_by(v); }
        if let Some(h) = hav { selector = selector.having(h); }
        for ob in ord { selector = selector.order_by_with_order(ob.variable.clone(), ob.order); }
        if let Some(l) = lim { selector = selector.limit(l).unwrap(); }
        if let Some(o) = off { selector = selector.offset(o).unwrap(); }
        let update_action = UpdateStreamAction { target_id: t_id, on_update_expression: Expression::value_bool(true), update_set_clause: None };
        let output_stream = OutputStream::new(OutputStreamAction::Update(update_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    // UPDATE OR INSERT INTO TABLE
    "from" <istream:InputStreamRule> "select" <sel:SelectList> <grp:GroupByOpt> <hav:HavingOpt> <ord:OrderByOpt> <lim:LimitOpt> <off:OffsetOpt> "update" "or" "insert" "into" <t_id:Ident> <set:SetClauseOpt> "on" <cond:Expression> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        for v in grp { selector = selector.group_by(v); }
        if let Some(h) = hav { selector = selector.having(h); }
        for ob in ord { selector = selector.order_by_with_order(ob.variable.clone(), ob.order); }
        if let Some(l) = lim { selector = selector.limit(l).unwrap(); }
        if let Some(o) = off { selector = selector.offset(o).unwrap(); }
        let action = UpdateOrInsertStreamAction { target_id: t_id, on_update_expression: cond, update_set_clause: set };
        let output_stream = OutputStream::new(OutputStreamAction::UpdateOrInsert(action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    // DELETE FROM TABLE with ON condition
    "from" <istream:InputStreamRule> "select" <sel:SelectList> <grp:GroupByOpt> <hav:HavingOpt> <ord:OrderByOpt> <lim:LimitOpt> <off:OffsetOpt> "delete" <t_id:Ident> "on" <cond:Expression> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        for v in grp { selector = selector.group_by(v); }
        if let Some(h) = hav { selector = selector.having(h); }
        for ob in ord { selector = selector.order_by_with_order(ob.variable.clone(), ob.order); }
        if let Some(l) = lim { selector = selector.limit(l).unwrap(); }
        if let Some(o) = off { selector = selector.offset(o).unwrap(); }
        let delete_action = DeleteStreamAction { target_id: t_id, on_delete_expression: cond };
        let output_stream = OutputStream::new(OutputStreamAction::Delete(delete_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    },
    // Legacy DELETE TABLE syntax
    "from" <istream:InputStreamRule> "select" <sel:SelectList> <grp:GroupByOpt> <hav:HavingOpt> <ord:OrderByOpt> <lim:LimitOpt> <off:OffsetOpt> "delete" "table" <t_id:Ident> => {
        let in_stream = istream;
        let mut selector = Selector::new();
        for (expr, alias) in sel {
            match alias {
                Some(a) => selector = selector.select(a, expr),
                None => match expr.clone() {
                    Expression::Variable(var) => selector = selector.select_variable(var),
                    _ => selector = selector.select(String::new(), expr),
                },
            }
        }
        for v in grp { selector = selector.group_by(v); }
        if let Some(h) = hav { selector = selector.having(h); }
        for ob in ord { selector = selector.order_by_with_order(ob.variable.clone(), ob.order); }
        if let Some(l) = lim { selector = selector.limit(l).unwrap(); }
        if let Some(o) = off { selector = selector.offset(o).unwrap(); }
        let delete_action = DeleteStreamAction { target_id: t_id, on_delete_expression: Expression::value_bool(true) };
        let output_stream = OutputStream::new(OutputStreamAction::Delete(delete_action), None);
        Query::query().from(in_stream).select(selector).out_stream(output_stream)
    }
};


pub PartitionStmt: Partition = {
    "partition" "with" "(" <first:PartitionWithStream> <rest:("," PartitionWithStream)*> ")" "begin" <qs:QueryList> "end" => {
        let mut p = Partition::partition().with_partition_type(first);
        for (_, pt) in rest { p = p.with_partition_type(pt); }
        for q in qs { p = p.add_query(q); }
        p
    },
    "define" "partition" "with" "(" <first:PartitionWithStream> <rest:("," PartitionWithStream)*> ")" "begin" <qs:QueryList> "end" => {
        let mut p = Partition::partition().with_partition_type(first);
        for (_, pt) in rest { p = p.with_partition_type(pt); }
        for q in qs { p = p.add_query(q); }
        p
    }
};

QueryList: Vec<Query> = {
    <first:QueryStmt> <rest:(";" QueryStmt)*> ";"? => {
        let mut v = vec![first];
        for (_, q) in rest { v.push(q); }
        v
    }
};

PartitionWithStream: PartitionType = {
    <expr:Expression> "of" <sid:Ident> => PartitionType::new_value(ValuePartitionType::new(sid, expr)),
    <cr:ConditionRanges> "of" <sid:Ident> => PartitionType::new_range(RangePartitionType::new(sid, cr)),
};

ConditionRanges: Vec<RangePartitionProperty> = {
    <first:ConditionRange> <rest:("or" ConditionRange)*> => {
        let mut v = vec![first];
        for (_, c) in rest { v.push(c); }
        v
    }
};

ConditionRange: RangePartitionProperty = { <expr:Expression> "as" <key:STRING> => RangePartitionProperty::new(key, expr) };


SelectList: Vec<(Expression, Option<String>)> = {
    <first:SelectItem> <rest:("," SelectItem)*> => {
        let mut v = vec![first];
        for (_, a) in rest { v.push(a); }
        v
    },
    => Vec::new()
};

SelectItem: (Expression, Option<String>) = {
    <e:Expression> "as" <a:Ident> => (e, Some(a)),
    <e:Expression> => (e, None),
};

GroupByClause: Vec<Variable> = {
    "group" "by" <first:Ident> <rest:("," Ident)*> => {
        let mut v = vec![Variable::new(first)];
        for (_, id) in rest { v.push(Variable::new(id)); }
        v
    }
};

GroupByOpt: Vec<Variable> = {
    <g:GroupByClause> => g,
    => Vec::new(),
};

HavingOpt: Option<Expression> = {
    "having" <e:Expression> => Some(e),
    => None,
};

OrderItem: OrderByAttribute = {
    <id:Ident> <o:OrderOpt> => {
        let var = Variable::new(id);
        match o {
            Some(OrderByOrder::Desc) => OrderByAttribute::new(var, OrderByOrder::Desc),
            Some(OrderByOrder::Asc) => OrderByAttribute::new(var, OrderByOrder::Asc),
            None => OrderByAttribute::new_default_order(var),
        }
    }
};

OrderOpt: Option<OrderByOrder> = {
    "desc" => Some(OrderByOrder::Desc),
    "asc" => Some(OrderByOrder::Asc),
    => None,
};

OrderByClause: Vec<OrderByAttribute> = {
    "order" "by" <first:OrderItem> <rest:("," OrderItem)*> => {
        let mut v = vec![first];
        for (_, it) in rest { v.push(it); }
        v
    }
};

OrderByOpt: Vec<OrderByAttribute> = {
    <o:OrderByClause> => o,
    => Vec::new(),
};

LimitOpt: Option<Constant> = {
    "limit" <n:NUMBER> => Some(Constant::long(n)),
    => None,
};

OffsetOpt: Option<Constant> = {
    "offset" <n:NUMBER> => Some(Constant::long(n)),
    => None,
};

AttrList: Vec<(String, AttributeType)> = {
    <first:Attribute> <rest:("," Attribute)*> => {
        let mut v = vec![first];
        for (_, a) in rest { v.push(a); }
        v
    },
    => Vec::new()
};

Attribute: (String, AttributeType) = { <name:Ident> <ty:Type> => (name, ty) };

DurationList: Vec<TimeDuration> = {
    <first:Duration> <rest:("," Duration)*> => {
        let mut v = vec![first];
        for (_, d) in rest { v.push(d); }
        v
    },
    => Vec::new()
};

Duration: TimeDuration = {
    "seconds" => TimeDuration::Seconds,
    "minutes" => TimeDuration::Minutes,
    "hours" => TimeDuration::Hours,
    "days" => TimeDuration::Days,
    "months" => TimeDuration::Months,
    "years" => TimeDuration::Years,
};

Type: AttributeType = {
    "string" => AttributeType::STRING,
    "int" => AttributeType::INT,
    "long" => AttributeType::LONG,
    "float" => AttributeType::FLOAT,
    "double" => AttributeType::DOUBLE,
    "bool" => AttributeType::BOOL,
    "boolean" => AttributeType::BOOL,
    "object" => AttributeType::OBJECT,
};

pub Expression: Expression = { <e:OrExpr> => e };

OrExpr: Expression = {
    <l:OrExpr> "or" <r:AndExpr> => Expression::or(l, r),
    <e:AndExpr> => e,
};

AndExpr: Expression = {
    <l:AndExpr> "and" <r:NotExpr> => Expression::and(l, r),
    <e:NotExpr> => e,
};

NotExpr: Expression = {
    "not" <e:NotExpr> => Expression::not(e),
    <e:CompareExpr> => e,
};

CompareExpr: Expression = {
    <l:AddExpr> ">=" <r:AddExpr> => Expression::compare(l, CompareOperator::GreaterThanEqual, r),
    <l:AddExpr> "<=" <r:AddExpr> => Expression::compare(l, CompareOperator::LessThanEqual, r),
    <l:AddExpr> ">" <r:AddExpr> => Expression::compare(l, CompareOperator::GreaterThan, r),
    <l:AddExpr> "<" <r:AddExpr> => Expression::compare(l, CompareOperator::LessThan, r),
    <l:AddExpr> "==" <r:AddExpr> => Expression::compare(l, CompareOperator::Equal, r),
    <l:AddExpr> "!=" <r:AddExpr> => Expression::compare(l, CompareOperator::NotEqual, r),
    <l:AddExpr> "in" <tbl:Ident> => Expression::in_op(l, tbl),
    <e:AddExpr> => e,
};

AddExpr: Expression = {
    <l:AddExpr> "+" <r:MulExpr> => Expression::add(l, r),
    <l:AddExpr> "-" <r:MulExpr> => Expression::subtract(l, r),
    <e:MulExpr> => e,
};

MulExpr: Expression = {
    <l:MulExpr> "*" <r:PrimaryExpr> => Expression::multiply(l, r),
    <l:MulExpr> "/" <r:PrimaryExpr> => Expression::divide(l, r),
    <e:PrimaryExpr> => e,
};

PrimaryExpr: Expression = {
    "(" <e:Expression> ")" => e,
    <s:STRING> => Expression::value_string(s),
    <n:NUMBER> => Expression::value_long(n),
    "-" <n:NUMBER> => Expression::value_long(-n),
    <tc:TimeConstant> => Expression::Constant(tc),
    <sid:Ident> "." <id:Ident> => Expression::Variable(Variable::new(id).of_stream(sid)),
    <ns:Ident> ":" <id:Ident> "(" <args:ExprList> ")" => Expression::function(Some(ns), id, args),
    <id:Ident> "(" <args:ExprList> ")" => Expression::function_no_ns(id, args),
    <id:Ident> => Expression::variable(id),
};

ExprList: Vec<Expression> = {
    <first:Expression> <rest:("," Expression)*> => {
        let mut v = vec![first];
        for (_, e) in rest { v.push(e); }
        v
    },
    => Vec::new()
};

Ident: String = { <r"[A-Za-z_][A-Za-z0-9_]*"> => <>.to_string() };

STRING: String = {
    <r#"'([^']*)'"#> => { let s = <>; s[1..s.len()-1].to_string() },
    <r#"\"([^\"]*)\""#> => { let s = <>; s[1..s.len()-1].to_string() },
};

NUMBER: i64 = { <r"[0-9]+"> => <>.parse().unwrap() };

TimeUnit: String = {
    "ms" => "ms".to_string(),
    "millisec" => "millisec".to_string(),
    "millisecs" => "millisecs".to_string(),
    "millisecond" => "millisecond".to_string(),
    "milliseconds" => "milliseconds".to_string(),
    "sec" => "sec".to_string(),
    "second" => "second".to_string(),
    "seconds" => "seconds".to_string(),
    "min" => "min".to_string(),
    "minute" => "minute".to_string(),
    "minutes" => "minutes".to_string(),
    "h" => "h".to_string(),
    "hour" => "hour".to_string(),
    "hours" => "hours".to_string(),
    "day" => "day".to_string(),
    "days" => "days".to_string(),
    "week" => "week".to_string(),
    "weeks" => "weeks".to_string(),
    "month" => "month".to_string(),
    "months" => "months".to_string(),
    "year" => "year".to_string(),
    "years" => "years".to_string(),
};

pub TimeConstant: Constant = {
    <n:NUMBER> <u:TimeUnit> => {
        let millis = match u.as_str() {
            "ms" | "millisec" | "millisecs" | "millisecond" | "milliseconds" => TimeUtil::millisec_val(n),
            "sec" | "second" | "seconds" => TimeUtil::sec_val(n),
            "min" | "minute" | "minutes" => TimeUtil::minute_val(n),
            "h" | "hour" | "hours" => TimeUtil::hour_val(n),
            "day" | "days" => TimeUtil::day_val(n),
            "week" | "weeks" => TimeUtil::week_val(n),
            "month" | "months" => TimeUtil::month_val(n),
            "year" | "years" => TimeUtil::year_val(n),
            _ => unreachable!(),
        };
        Constant::time(millis)
    }
};

